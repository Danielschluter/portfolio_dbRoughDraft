<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PDF Upload and Display with Table Extraction</title>
    <style>
        #pdf-canvas {
            border: 1px solid black;
        }
        #extracted-text {
            white-space: pre-wrap; /* Preserve line breaks and spaces */
            font-family: monospace; /* For better alignment */
        }
    </style>
</head>
<body>
    <input type="file" id="pdfUpload" accept="application/pdf">
    <button id="prevPage">Previous</button>
    <span id="page_num"></span> / <span id="page_count"></span>
    <button id="nextPage">Next</button>
    <br><br>
    <canvas id="pdf-canvas"></canvas>
    <br><br>
    <h2>Extracted Table Data (Page <span id="extracted_page_num"></span>):</h2>
    <pre id="extracted-text"></pre>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js"></script>

    <script>
        const fileInput = document.getElementById('pdfUpload');
        const prevPageBtn = document.getElementById('prevPage');
        const nextPageBtn = document.getElementById('nextPage');
        const pageNumSpan = document.getElementById('page_num');
        const pageCountSpan = document.getElementById('page_count');
        const extractedPageNumSpan = document.getElementById('extracted_page_num');
        const extractedTextPre = document.getElementById('extracted-text');
        const canvas = document.getElementById('pdf-canvas');
        const context = canvas.getContext('2d');

        let pdfDoc = null;
        let pageNum = 1;
        let pageRendering = false;
        let pageNumPending = null;
        const scale = 1.5;

        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';

        async function renderPage(num) {
            pageRendering = true;
            const page = await pdfDoc.getPage(num);
            const viewport = page.getViewport({ scale: scale });
            canvas.height = viewport.height;
            canvas.width = viewport.width;

            const renderContext = {
                canvasContext: context,
                viewport: viewport
            };

            const renderTask = page.render(renderContext);
            await renderTask.promise;
            pageRendering = false;

            if (pageNumPending !== null) {
                renderPage(pageNumPending);
                pageNumPending = null;
            }
            pageNumSpan.textContent = num;
            extractedPageNumSpan.textContent = num;

            // Extract text from the current page and attempt to detect tables
            await extractTableData(page);
        }

        async function extractTableData(page) {
            const textContent = await page.getTextContent();
            let extractedTable = [];
            let currentRow = [];
            let previousY = -1;

            // Group text items by rows based on Y position
            textContent.items.forEach(item => {
                const y = item.transform[5];
                const height = item.height || 12;

                if (previousY !== -1 && Math.abs(y - previousY) > height * 0.8) {
                    if (currentRow.length > 0) {
                        extractedTable.push(currentRow);
                    }
                    currentRow = [];
                }
                currentRow.push({ 
                    text: item.str.trim(), 
                    x: item.transform[4], 
                    y: y,
                    width: item.width || 0
                });
                previousY = y;
            });
            
            if (currentRow.length > 0) {
                extractedTable.push(currentRow);
            }

            // Parse holdings data
            const holdings = parseHoldingsFromTable(extractedTable);
            
            // Display both raw table and parsed holdings
            let output = "=== PARSED HOLDINGS ===\n";
            if (holdings.length > 0) {
                output += "Ticker\tShares\tMarket Value\tCost Basis\n";
                output += "â”€".repeat(50) + "\n";
                holdings.forEach(holding => {
                    output += `${holding.ticker}\t${holding.shares}\t$${holding.marketValue}\t$${holding.costBasis}\n`;
                });
            } else {
                output += "No holdings found. Check the raw table data below.\n";
            }

            output += "\n=== RAW TABLE DATA ===\n";
            extractedTable.forEach((row, idx) => {
                row.sort((a, b) => a.x - b.x);
                const rowText = row.map(item => item.text).filter(text => text.length > 0).join('\t');
                if (rowText.trim()) {
                    output += `Row ${idx + 1}: ${rowText}\n`;
                }
            });

            extractedTextPre.textContent = output;
        }

        function parseHoldingsFromTable(table) {
            const holdings = [];
            
            // Common patterns for ticker symbols (1-5 uppercase letters, sometimes with numbers)
            const tickerPattern = /^[A-Z]{1,5}[0-9]*$/;
            
            // Patterns for currency amounts (with or without $ sign, with commas)
            const currencyPattern = /^\$?[\d,]+\.?\d*$/;
            const numberPattern = /^[\d,]+\.?\d*$/;

            table.forEach(row => {
                if (row.length < 3) return; // Need at least ticker and 2 values
                
                row.sort((a, b) => a.x - b.x);
                const texts = row.map(item => item.text.trim()).filter(text => text.length > 0);
                
                // Look for patterns: Ticker, Shares, Market Value, Cost Basis
                for (let i = 0; i < texts.length - 2; i++) {
                    const potentialTicker = texts[i];
                    
                    // Check if this looks like a ticker symbol
                    if (tickerPattern.test(potentialTicker)) {
                        const remainingTexts = texts.slice(i + 1);
                        
                        // Try to find numeric values after the ticker
                        const numericValues = [];
                        for (const text of remainingTexts) {
                            if (numberPattern.test(text) || currencyPattern.test(text)) {
                                // Clean the number (remove $ and commas)
                                const cleanValue = text.replace(/[$,]/g, '');
                                if (!isNaN(parseFloat(cleanValue))) {
                                    numericValues.push(parseFloat(cleanValue));
                                }
                            }
                        }
                        
                        // If we have at least 2-3 numeric values, treat as a holding
                        if (numericValues.length >= 2) {
                            const holding = {
                                ticker: potentialTicker,
                                shares: numericValues[0] || 0,
                                marketValue: numericValues[1] || 0,
                                costBasis: numericValues[2] || numericValues[1] // Use market value if cost basis not available
                            };
                            
                            // Basic validation - skip if values seem unreasonable
                            if (holding.shares > 0 && holding.marketValue > 0) {
                                holdings.push(holding);
                            }
                        }
                        break; // Move to next row after processing this ticker
                    }
                }
            });

            return holdings;
        }

        function queueRenderPage(num) {
            if (pageRendering) {
                pageNumPending = num;
            } else {
                renderPage(num);
            }
        }

        function onPrevPage() {
            if (pageNum <= 1) {
                return;
            }
            pageNum--;
            queueRenderPage(pageNum);
        }

        function onNextPage() {
            if (pageNum >= pdfDoc.numPages) {
                return;
            }
            pageNum++;
            queueRenderPage(pageNum);
        }

        fileInput.addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (file && file.type === 'application/pdf') {
                const reader = new FileReader();

                reader.onload = async function() {
                    const typedarray = new Uint8Array(this.result);
                    const loadingTask = pdfjsLib.getDocument({ data: typedarray });
                    pdfDoc = await loadingTask.promise;
                    pageCountSpan.textContent = pdfDoc.numPages;
                    pageNum = 1; // Reset page number to 1 for the new PDF
                    renderPage(pageNum);
                };

                reader.readAsArrayBuffer(file);
            } else {
                alert('Please upload a valid PDF file.');
            }
        });

        prevPageBtn.addEventListener('click', onPrevPage);
        nextPageBtn.addEventListener('click', onNextPage);
    </script>
</body>
</html>
